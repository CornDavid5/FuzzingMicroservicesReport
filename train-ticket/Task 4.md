# How to Deploy
Prerequisite:
- docker
- kubernetes
    - I use `minikube` for my local deployment

Following steps are for `kubernetes quickstart` deployment:
- Clone my instrumented repo, run `git clone git@github.com:CornDavid5/train-ticket.git`
- Deploy all services, run `make deploy`
- Once all services is up and running, you can visit the ui in your browser
    - If you are using k8s, you can find `ts-ui-dashboard`'s node ip using `kubectl get nodes -o wide`, then visit [http://[Node-IP]:32677]()
    - If you are using `minikube`, you can expose the port using `minikube service ts-ui-dashboard --url`, then visit the url provided in the command line
- Two set of log in credential are provided
    - User: username: `fdse_microservice`, password: `111111`
    - Admin: username: `admin`, password: `222222`

Note:
- I made a few changes related to kubernetes deployment configuration for different services. Because the original configuration requires some beefy computation resources, which prevents us from running it on our local machine, I modified the replica count as well as maximum memory and CPU time allowed for every service.
- The original authors have not maintained docker deployment approach, the base image used in the dockerfile is either wrong or had already been removed from the Docker Hub, for example, `python:3` should change to `python:3.8-buster` and `java:8-jre` should change to `openjdk:8-jre`
- You can find screenshots for the running app in [here](./resources/screenshot/)

# Code Coverage
Most of the services is written in Java, and it uses `mockito` as mocking framework and `junit` as testing framework. However, feels like the development team have not maintained the tests for a while, many tests will not pass without modifications. I modified the source code and the following modules can pass the tests:
- ts-admin-basic-info-service
- ts-admin-user-service
- ts-cancel-service
- ts-contacts-service
- ts-route-plan-service

The coverage files generated by `JaCoCo` are in [here](./coverage/)

If you want to generate the coverage by yourself, using following steps:
- Clone my instrumented repo, run `git clone git@github.com:CornDavid5/train-ticket.git`
- Generate coverage for one module, run `mvn test -pl ts-route-plan-service -am`

## Modification Examples
In the original tests, there are parameters that are tightly tied to developers' own development environment.
``` java
@Test
public void testGetAllContacts() {
    Mockito.when(restTemplate.exchange(
            "http://ts-contacts-service:12347/api/v1/contactservice/contacts",
            HttpMethod.GET,
            requestEntity,
            Response.class)).thenReturn(re);
    response = adminBasicInfoService.getAllContacts(headers);
    Assert.assertEquals(new Response<>(null, null, null), response);
}
```

Should be changed to:

``` java
@Test
public void testGetAllContacts() {
    Mockito.when(restTemplate.exchange(
            Mockito.contains("/api/v1/contactservice/contacts"),
            Mockito.eq(HttpMethod.GET),
            Mockito.eq(requestEntity),
            Mockito.eq(Response.class))).thenReturn(re);
    response = adminBasicInfoService.getAllContacts(headers);
    Assert.assertEquals(new Response<>(null, null, null), response);
}
```

Or, the implementation of function is changed, but the test still expects the old implementation.

``` java
@Test
public void testCreateContacts1() {
    Contacts contacts = new Contacts();
    Mockito.when(contactsRepository.findById(Mockito.any(UUID.class).toString())).thenReturn(Optional.of(contacts));
    Response result = contactsServiceImpl.createContacts(contacts, headers);
    Assert.assertEquals(new Response<>(0, "Already Exists", contacts), result);
}
```

Should be changed to:

``` java
@Test
public void testCreateContacts1() {
    UUID id = UUID.randomUUID();
    Contacts contacts = new Contacts(id.toString(), id.toString(), "name", 1, "12", "10001");
    Mockito.when(contactsRepository.findByAccountIdAndDocumentTypeAndDocumentType(id.toString(), "12", 1)).thenReturn(contacts);
    Response result = contactsServiceImpl.createContacts(contacts, headers);
    Assert.assertEquals(new Response<>(0, "Already Exists", contacts), result);
}
```

Or, API URL changed, but test still uses old URL.

``` java
@Test
public void testDeleteStation() throws Exception {
    Station s = new Station();
    Mockito.when(adminBasicInfoService.deleteStation(Mockito.anyString(), Mockito.any(HttpHeaders.class))).thenReturn(response);
    String requestJson = JSONObject.toJSONString(s);
    String result = mockMvc.perform(MockMvcRequestBuilders.delete("/api/v1/adminbasicservice/adminbasic/stations").contentType(MediaType.APPLICATION_JSON).content(requestJson))
            .andExpect(MockMvcResultMatchers.status().isOk())
            .andReturn().getResponse().getContentAsString();
    Assert.assertEquals(response, JSONObject.parseObject(result, Response.class));
}
```

Should be changed to:

``` java
@Test
public void testDeleteStation() throws Exception {
    Station s = new Station();
    Mockito.when(adminBasicInfoService.deleteStation(Mockito.anyString(), Mockito.any(HttpHeaders.class))).thenReturn(response);
    String requestJson = JSONObject.toJSONString(s);
    String result = mockMvc.perform(MockMvcRequestBuilders.delete("/api/v1/adminbasicservice/adminbasic/stations/id").contentType(MediaType.APPLICATION_JSON).content(requestJson))
            .andExpect(MockMvcResultMatchers.status().isOk())
            .andReturn().getResponse().getContentAsString();
    Assert.assertEquals(response, JSONObject.parseObject(result, Response.class));
}
```
